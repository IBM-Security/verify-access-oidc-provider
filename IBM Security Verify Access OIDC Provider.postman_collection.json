{
	"info": {
		"_postman_id": "f9b94f13-8b87-421e-9600-312a6e885ae0",
		"name": "IBM Security Verify Access OIDC Provider",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "JWKS",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Content-Type is present\", function () {",
							"    pm.response.to.have.header(\"Content-Type\");",
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"});",
							"var schema = {",
							"    \"keys\": [",
							"        {",
							"            \"use\": \"sig\",",
							"            \"kty\": \"EC\",",
							"            \"kid\": \"es256\",",
							"            \"crv\": \"P-256\",",
							"            \"x\": \"2eFMhRrJ32E2iMUd8yqTH1S1R0iUNeJVkpxEtEcAK58\",",
							"            \"y\": \"GpCy6KiKO4cFyeuAz8wUpBUHQmx0SX0YnswvZaSKkEc\"",
							"        },",
							"        {",
							"            \"use\": \"sig\",",
							"            \"kty\": \"RSA\",",
							"            \"kid\": \"httpserver\",",
							"            \"n\": \"p30DhlZ8sr5ZDi6prRvKL4M9ErQJ4ZYZST153m_xBP68ft-vuLOLLzl8pAXBW5IqR0YEchGQPJtUQjqE4j7ht-rqN2WQxLVzUdc9FGi2VDADdRvBncpBgSjueU-tSblcZ6LSF0UPeM2z5xTdMSgWRJ9xff_cvHJTpACdG2EWwe8u9a9yzVz_dqLbVugy415Cotp3DiZyIjHVEADvJY9Xlxk4E39lCKOMQlAFMPH76HnXCrVCi4MZeokCYHBzH_8ue29ImhLAZRE83F9r0mhfx37lAraut3rr6sRponY4wBRaEXpNrVlcTTNMyvL272TCkEZqtm4mwepVhNYj7Pxblw\",",
							"            \"e\": \"AQAB\"",
							"        },",
							"        {",
							"            \"use\": \"sig\",",
							"            \"kty\": \"RSA\",",
							"            \"kid\": \"mtls01\",",
							"            \"n\": \"ppY9BFOF6YXRPSRv-p21I6l-9OiTF_JbjzQ3zbvkhwkQ8p30chePHLQVeBBev1oV5j_oGYzD2_hUkUcqueHETuOFTaZ8Z0VpN9c2HDXTZ4IeTUpPJPPWcqJ4ykWxtZdhgWbxjn5lROzupAUrsT9nJci4_8KgEu6vaTnIo-NLVwzFkNr9cMYRBcg7O20RL7V7LSgGyqw2vUK3jvBCgsCZSWRjjBQiYGQjEYkvGmAm22Omw2HmdJ0mFV4m7DpyY2WRhLqSAedzkwsYioTDPXqa-ts8DgBqUySPYp1ACSoeHxVO5gnKd6ukaCNyh5U7bui0zMRw_NKRGChA1nJN3cg1Mw\",",
							"            \"e\": \"AQAB\"",
							"        },",
							"        {",
							"            \"use\": \"sig\",",
							"            \"kty\": \"RSA\",",
							"            \"kid\": \"rsa256\",",
							"            \"n\": \"toihHnUntP41DGJEpUQjHuzyWtb4NQEg5r38YoaCRVfnX7pmYOgn6zOU3jgUXuNqJefTHNLRq7_wxZT2zsCFrJvfg8ccl4Ds1Vp3Hur3mQVsqhXrKRqBvvsF_1pbJSbyLCk0_HkrcP9XRNP4Lq2MiofAtt89Lmya9ZlwbA4NLkEJFNtC-6wuq48kpA-TWXOcQXPUW-0RZS7t8DGgRlQpeUwj8-g6N_uUSk21hawGNlWmOYkrQ7w4kCIKO2U4Y6_2dygwNnESxiPA_61UuH9wVjWxo1XiyKJnpDGiYXGeihoGn6EcLMKeA8wACuR_1ah7BD3iKMQRW3DWEBfjp0LMyQ\",",
							"            \"e\": \"AQAB\"",
							"        },",
							"        {",
							"            \"use\": \"enc\",",
							"            \"kty\": \"EC\",",
							"            \"kid\": \"es256\",",
							"            \"crv\": \"P-256\",",
							"            \"x\": \"2eFMhRrJ32E2iMUd8yqTH1S1R0iUNeJVkpxEtEcAK58\",",
							"            \"y\": \"GpCy6KiKO4cFyeuAz8wUpBUHQmx0SX0YnswvZaSKkEc\"",
							"        },",
							"        {",
							"            \"use\": \"enc\",",
							"            \"kty\": \"RSA\",",
							"            \"kid\": \"httpserver\",",
							"            \"n\": \"p30DhlZ8sr5ZDi6prRvKL4M9ErQJ4ZYZST153m_xBP68ft-vuLOLLzl8pAXBW5IqR0YEchGQPJtUQjqE4j7ht-rqN2WQxLVzUdc9FGi2VDADdRvBncpBgSjueU-tSblcZ6LSF0UPeM2z5xTdMSgWRJ9xff_cvHJTpACdG2EWwe8u9a9yzVz_dqLbVugy415Cotp3DiZyIjHVEADvJY9Xlxk4E39lCKOMQlAFMPH76HnXCrVCi4MZeokCYHBzH_8ue29ImhLAZRE83F9r0mhfx37lAraut3rr6sRponY4wBRaEXpNrVlcTTNMyvL272TCkEZqtm4mwepVhNYj7Pxblw\",",
							"            \"e\": \"AQAB\"",
							"        },",
							"        {",
							"            \"use\": \"enc\",",
							"            \"kty\": \"RSA\",",
							"            \"kid\": \"mtls01\",",
							"            \"n\": \"ppY9BFOF6YXRPSRv-p21I6l-9OiTF_JbjzQ3zbvkhwkQ8p30chePHLQVeBBev1oV5j_oGYzD2_hUkUcqueHETuOFTaZ8Z0VpN9c2HDXTZ4IeTUpPJPPWcqJ4ykWxtZdhgWbxjn5lROzupAUrsT9nJci4_8KgEu6vaTnIo-NLVwzFkNr9cMYRBcg7O20RL7V7LSgGyqw2vUK3jvBCgsCZSWRjjBQiYGQjEYkvGmAm22Omw2HmdJ0mFV4m7DpyY2WRhLqSAedzkwsYioTDPXqa-ts8DgBqUySPYp1ACSoeHxVO5gnKd6ukaCNyh5U7bui0zMRw_NKRGChA1nJN3cg1Mw\",",
							"            \"e\": \"AQAB\"",
							"        },",
							"        {",
							"            \"use\": \"enc\",",
							"            \"kty\": \"RSA\",",
							"            \"kid\": \"rsa256\",",
							"            \"n\": \"toihHnUntP41DGJEpUQjHuzyWtb4NQEg5r38YoaCRVfnX7pmYOgn6zOU3jgUXuNqJefTHNLRq7_wxZT2zsCFrJvfg8ccl4Ds1Vp3Hur3mQVsqhXrKRqBvvsF_1pbJSbyLCk0_HkrcP9XRNP4Lq2MiofAtt89Lmya9ZlwbA4NLkEJFNtC-6wuq48kpA-TWXOcQXPUW-0RZS7t8DGgRlQpeUwj8-g6N_uUSk21hawGNlWmOYkrQ7w4kCIKO2U4Y6_2dygwNnESxiPA_61UuH9wVjWxo1XiyKJnpDGiYXGeihoGn6EcLMKeA8wACuR_1ah7BD3iKMQRW3DWEBfjp0LMyQ\",",
							"            \"e\": \"AQAB\"",
							"        }",
							"    ]",
							"};",
							"",
							"",
							"pm.test('Schema is valid', function() {",
							"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true;",
							"});",
							"",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/jwks",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"jwks"
					]
				},
				"description": "Retrieve authorization server public keys used for JWT signing or encryption operations."
			},
			"response": []
		},
		{
			"name": "Well-known Endpoint",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/.well-known/openid-configuration",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						".well-known",
						"openid-configuration"
					]
				},
				"description": "Retrieve metadata for the authorization server as a JSON document, which declares its endpoint locations and authorization server capabilities."
			},
			"response": []
		},
		{
			"name": "api: Client Credentials flow",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.environment.set(\"token\",  pm.response.json().access_token);"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disableCookies": true,
				"tlsPreferServerCiphers": true
			},
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "password",
							"value": "{{client_api_secret}}",
							"type": "string"
						},
						{
							"key": "username",
							"value": "{{client_api_id}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "scope",
							"value": "profile",
							"type": "text"
						},
						{
							"key": "grant_type",
							"value": "client_credentials",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/token",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "#### Overview\n\nThe Client Credentials grant is used when applications request an access token to access their own resources, not on behalf of a user.\n\nThe client needs to authenticate themselves for this request.\n\nIn this example, the client authentication is done using `client_secret_basic` method, where the `client_id` and `client_secret` is supplied in the `Authorization basic` header."
			},
			"response": []
		},
		{
			"name": "api: Introspect",
			"protocolProfileBehavior": {
				"disableCookies": true,
				"tlsPreferServerCiphers": true
			},
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "password",
							"value": "{{client_api_secret}}",
							"type": "string"
						},
						{
							"key": "username",
							"value": "{{client_api_id}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "token",
							"value": "{{token}}",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/introspect",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"introspect"
					]
				},
				"description": "#### Overview\n\nQuery the authorization server to determine the set of metadata for a given token.\nThis metadata includes whether or not the token is currently active (or if it has expired or otherwise been revoked), what rights of access the token carries (usually conveyed through OAuth 2.0 scopes), and the authorization context in which the token was granted (including who authorized the token and which client it was issued to).\n\nThis endpoint is protected by client authentication.\n\nIn this example, `client_secret_basic` is used"
			},
			"response": []
		},
		{
			"name": "ropc: Resource Owner Password Credentials Grant",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"pm.test(\"Check Scope\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.scope).to.eql('openid profile');",
							"});",
							"pm.test(\"Check token_type\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.token_type).to.eql('bearer');",
							"});",
							"pm.environment.set(\"token\",  pm.response.json().access_token);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "scope",
							"value": "openid profile",
							"type": "text"
						},
						{
							"key": "grant_type",
							"value": "password",
							"type": "text"
						},
						{
							"key": "username",
							"value": "{{username}}",
							"type": "text"
						},
						{
							"key": "password",
							"value": "{{password}}",
							"type": "text"
						},
						{
							"key": "client_id",
							"value": "{{client_ropc_id}}",
							"type": "text"
						},
						{
							"key": "client_secret",
							"value": "{{client_ropc_secret}}",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/token",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "#### Overview\n\nThe resource owner password credentials grant workflow allows for the exchanging of the user name and password of a user for an access token. When using the resource owner password credentials grant, the user provides the credentials (user name and password) directly to the application.\n\nIn this example, the client authentication is done using `client_secret_post` method, where the `client_id` and `client_secret` is supplied in the POST body."
			},
			"response": []
		},
		{
			"name": "ropc: Introspect",
			"protocolProfileBehavior": {
				"disableCookies": true,
				"tlsPreferServerCiphers": true
			},
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "client_id",
							"value": "{{client_ropc_id}}",
							"type": "text"
						},
						{
							"key": "client_secret",
							"value": "{{client_ropc_secret}}",
							"type": "text"
						},
						{
							"key": "token",
							"value": "{{token}}",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/introspect",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"introspect"
					]
				},
				"description": "#### Overview\n\nQuery the authorization server to determine the set of metadata for a given token.\nThis metadata includes whether or not the token is currently active (or if it has expired or otherwise been revoked), what rights of access the token carries (usually conveyed through OAuth 2.0 scopes), and the authorization context in which the token was granted (including who authorized the token and which client it was issued to).\n\nThis endpoint is protected by client authentication.\n\nIn this example, `client_secret_post` is used"
			},
			"response": []
		},
		{
			"name": "ropc: UserInfo",
			"protocolProfileBehavior": {
				"disableCookies": true,
				"tlsPreferServerCiphers": true
			},
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "access_token",
							"value": "{{token}}",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/userinfo",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"userinfo"
					]
				},
				"description": "#### Overview\n\nQuery the user information using the `access_token` generated.\n\nThis endpoint only require a valid `access_token`."
			},
			"response": []
		},
		{
			"name": "dcr: Get Bearer Token For DCR",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.environment.set(\"token\",  pm.response.json().access_token);"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disableCookies": true,
				"disableUrlEncoding": true,
				"tlsPreferServerCiphers": true
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "X-Client-Certificate",
						"type": "text",
						"value": "{{x-client-certificate}}",
						"description": "only needed if you test directly to ISVAOP container"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "client_id",
							"value": "{{client_dcr_owner_id}}",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "openid cdr:registration",
							"type": "text"
						},
						{
							"key": "grant_type",
							"value": "client_credentials",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/token",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "#### Overview\n\nWhen the `POST /register` is protected by a bearer token, the `access_token` need to be generated first.\n\nIn this example, we generate the initial `access_token` using `client_credentials` flow with MTLS authentication.\n\nISVA OP deployment typically is fronted by a reverse proxy. So the MTLS connection is terminated there. Then the reverse proxy will forward the client certificate in an HTTP header (configurable in `provider.yml`) to ISVA OP.\n\nISVA OP will extract information from the client certificate, such as subject DN, and will match it with information in the client configuration.\n\nHere is the typical client configuration for MTLS client authentication to work:\n```\ntoken_endpoint_auth_method: tls_client_auth\ntls_client_auth_subject_dn: CN=clientID01,OU=security,O=IBM,L=singapore,ST=singapore,C=SG\ntls_client_certificate_bound_access_tokens: true // optional: to bound the access token with the certificate\n```\nNote: if you are testing with fronted reverse proxy, then you only need to configure postman to send client certificate. However, if you directly hitting ISVA OP container, you can simulate it by sending `X-Client-Certificate` header."
			},
			"response": []
		},
		{
			"name": "dcr: Dynamic Client Registration",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.environment.set(\"dynamic_client_id\", pm.response.json().client_id);",
							"pm.environment.set(\"dynamic_client_secret\", pm.response.json().client_secret);",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"tlsPreferServerCiphers": false,
				"disableCookies": false
			},
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{token}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\n    \"client_name\": \"Dynamic Client\",\n    \"grant_types\": [\n        \"authorization_code\",\n        \"client_credentials\"\n    ],\n    \"response_types\": [\n        \"code\",\n        \"code token\"\n    ],\n    \"redirect_uris\": [\n        \"https://myapp.com\",\n        \"https://www.google.com\"\n    ]\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/register",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"register"
					]
				},
				"description": "Dynamically register a client with the OIDC Provider. In the process, client is able to present a set of metadata, such as a set of valid redirection URIs. The metadata can either be communicated in a self-asserted fashion or as a set of metadata called a software statement, which is digitally signed; in the case of a software statement, the issuer is vouching for the validity of the data about the client."
			},
			"response": []
		},
		{
			"name": "dcr: Client Credential using Dynamic Client",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.environment.set(\"token\",  pm.response.json().access_token);"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"tlsPreferServerCiphers": true
			},
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "client_id",
							"value": "{{dynamic_client_id}}",
							"type": "text"
						},
						{
							"key": "client_secret",
							"value": "{{dynamic_client_secret}}",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "openid",
							"type": "text"
						},
						{
							"key": "grant_type",
							"value": "client_credentials",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/token",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "The Client Credentials grant is used when applications request an access token to access their own resources, not on behalf of a user.\n\nThe client needs to authenticate themselves for this request. When `token_endpoint_auth_method` is not configured, either `client_secret_post` or `client_secret_basic` are accepted.\n\nIn this example, we use `client_secret_post` method."
			},
			"response": []
		},
		{
			"name": "dcr: Introspect using Dynamic Client",
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "client_id",
							"value": "{{dynamic_client_id}}",
							"type": "text"
						},
						{
							"key": "client_secret",
							"value": "{{dynamic_client_secret}}",
							"type": "text"
						},
						{
							"key": "token",
							"value": "{{token}}",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/introspect",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"introspect"
					]
				},
				"description": "#### Overview\n\nQuery the authorization server to determine the set of metadata for a given token.\nThis metadata includes whether or not the token is currently active (or if it has expired or otherwise been revoked), what rights of access the token carries (usually conveyed through OAuth 2.0 scopes), and the authorization context in which the token was granted (including who authorized the token and which client it was issued to).\n\nThis endpoint is protected by client authentication.\n\nIn this example, `client_secret_post` is used"
			},
			"response": []
		},
		{
			"name": "basic: Authorization Code",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const $ = cheerio.load(pm.response.text());",
							"const $form = $('form');",
							"const action = $form.attr('action');",
							"pm.environment.set(\"consentPath\", action)"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disabledSystemHeaders": {},
				"followRedirects": false,
				"disableBodyPruning": true
			},
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "iv-jwt",
						"value": "{{iv-jwt}}",
						"description": "needed to simulate user session",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": []
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/authorize?client_id={{client_basic_id}}&response_type=code&redirect_uri=https://www.google.com&state=mWSGWl32gshyawaogasz54zmzlstu&scope=openid profile email&nonce=ahaw2eoagaw3awgaowco76awfao&code_challenge=k4Lnmw_E8IQDa28KUJw0FWCHStMduuRKfltH1roBkg4&code_challenge_method=S256",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"authorize"
					],
					"query": [
						{
							"key": "client_id",
							"value": "{{client_basic_id}}"
						},
						{
							"key": "response_type",
							"value": "code"
						},
						{
							"key": "redirect_uri",
							"value": "https://www.google.com"
						},
						{
							"key": "state",
							"value": "mWSGWl32gshyawaogasz54zmzlstu"
						},
						{
							"key": "scope",
							"value": "openid profile email"
						},
						{
							"key": "nonce",
							"value": "ahaw2eoagaw3awgaowco76awfao"
						},
						{
							"key": "code_challenge",
							"value": "k4Lnmw_E8IQDa28KUJw0FWCHStMduuRKfltH1roBkg4"
						},
						{
							"key": "code_challenge_method",
							"value": "S256"
						},
						{
							"key": "claims",
							"value": "{\"userinfo\":{\"openbanking_intent_id\":{\"value\":\"urn:alphabank-intent-58923\",\"essential\":true}},\"id_token\":{\"openbanking_intent_id\":{\"value\": \"urn-alphabank-intent-58923\",\"essential\":true},\"acr\":{\"essential\":true,\"values\":[\"urn:openbanking:psd2:sca\",\"urn:openbanking:psd2:ca\"]}}}",
							"disabled": true
						}
					]
				},
				"description": "Authorization code flow is a browser flow to acquire `access_token`.\nSo typically, you should copy the URL here and do it from the browser.\n\nThe steps here is provided to simulate the authorization code flow using postman.\n\nIn this postman collection, the user credential is injected using `iv-jwt` header. This is telling the system that the user has logged in.\n\nIn the actual deployment, ISVA OP will be fronted by a reverse proxy. This user session will be manage by the reverse proxy and forwarded to ISVA OP.\n\nWhen `iv-jwt` header is not available, the system will redirect you to `/oauth2/auth` endpoint to trigger user login.\n\nWhen `definition` configure the `consent_prompt` as `ALWAYS_PROMPT`, this step will result in consent page being returned. Otherwise, this step may return the `authorization_code` directly."
			},
			"response": []
		},
		{
			"name": "basic: Submit Consent",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const querystring = require('querystring');",
							"let params = pm.response.headers.get('location').split('?')",
							"pm.environment.set(\"auth_code\", querystring.parse(params[1]).code)"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "iv-jwt",
						"value": "{{iv-jwt}}",
						"type": "text",
						"description": "needed to simulate user session"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "trust_level",
							"value": "permit",
							"description": "permit or deny",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "openid",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "profile",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "email",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}{{consentPath}}",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}{{consentPath}}"
				},
				"description": "If the previous step returned a consent page, this step is used to submit the consents.\n\nWhen the consent decision is to `permit`, then `authorization_code` is returned as requested."
			},
			"response": []
		},
		{
			"name": "basic: Exchange Auth Code",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"pm.test(\"Check token_type\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.token_type).to.eql('bearer');",
							"});",
							"pm.environment.set(\"token\",  pm.response.json().access_token);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "grant_type",
							"value": "authorization_code",
							"type": "text"
						},
						{
							"key": "redirect_uri",
							"value": "https://www.google.com",
							"type": "text"
						},
						{
							"key": "code",
							"value": "{{auth_code}}",
							"type": "text"
						},
						{
							"key": "code_verifier",
							"value": "09jR4DQJIqyFUy2i-PllgD~Li6RbGqvORtTsrnktqjtYis5fMa_tO_--QT9r7d6vazhBfofnSj9JLzyI2u3PYflfi_VL.84dEhZ6yQ.fxCB9T9r7aB7lVUrIVwsUy7Ds",
							"type": "text"
						},
						{
							"key": "client_assertion",
							"value": "{{private_key_jwt}}",
							"type": "text"
						},
						{
							"key": "client_assertion_type",
							"value": "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/token",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "#### Overview\n\nAfter receiving the authorization code, we exchange it with the `access_token` at the /token endpoint. \n\nThis client is configured to use `private_key_jwt`. The `private_key_jwt` has expiry.\n\nIf it's already expired, you can copy the current `private_key_jwt` from your environment; paste into `jwt.io` website. Then modify the `exp` claim.\n\nIn order to sign it again properly, need to copy the private key and public key supplied in the enablement materials under `keys/private_key_jwt`. Then copy paste it back to your postman environment."
			},
			"response": []
		},
		{
			"name": "hybrid: Code IDToken with Request Object",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const $ = cheerio.load(pm.response.text());",
							"const $form = $('form');",
							"const action = $form.attr('action');",
							"pm.environment.set(\"consentPath\", action)"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disabledSystemHeaders": {},
				"followRedirects": false,
				"disableBodyPruning": true
			},
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "iv-jwt",
						"value": "{{iv-jwt}}",
						"description": "needed to simulate user session",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": []
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/authorize?client_id={{client_basic_id}}&request={{request_object}}",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"authorize"
					],
					"query": [
						{
							"key": "client_id",
							"value": "{{client_basic_id}}"
						},
						{
							"key": "request",
							"value": "{{request_object}}"
						}
					]
				},
				"description": "Similar with authorization code flow, the hybrid flow is also a browser flow to acquire `access_token`. It is `hybrid` because it is a mix of `authorization code` and `implicit` flow.\n\nSo typically, you should copy the URL here and do it from the browser.\n\nThe steps here is provided to simulate the hybrid flow using postman.\n\nIn this example, the request parameters are sent using `request object`. The `request object` here doesn't have any expiry, so it should work as is. There are advance settings in `provider.yml` in regards to `request object` to comply with FAPI requirements.\n\nIn this postman collection, the user credential is injected using `iv-jwt` header. This is telling the system that the user has logged in.\n\nIn the actual deployment, ISVA OP will be fronted by a reverse proxy. This user session will be manage by the reverse proxy and forwarded to ISVA OP.\n\nWhen `iv-jwt` header is not available, the system will redirect you to `/oauth2/auth` endpoint to trigger user login.\n\nWhen `definition` configure the `consent_prompt` as `ALWAYS_PROMPT`, this step will result in consent page being returned. Otherwise, this step may return the `authorization_code` and `id_token` directly."
			},
			"response": []
		},
		{
			"name": "hybrid: Submit Consent",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const querystring = require('querystring');",
							"let params = pm.response.headers.get('location').split('#')",
							"pm.environment.set(\"auth_code\", querystring.parse(params[1]).code)"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "iv-jwt",
						"value": "{{iv-jwt}}",
						"type": "text",
						"description": "needed to simulate user session"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "trust_level",
							"value": "permit",
							"description": "permit or deny",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "openid",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "profile",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}{{consentPath}}",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}{{consentPath}}"
				},
				"description": "If the previous step returned a consent page, this step is used to submit the consents.\n\nWhen the consent decision is to `permit`, then `authorization_code` and `id_token` is returned as requested."
			},
			"response": []
		},
		{
			"name": "hybrid: Exchange Auth Code",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"pm.test(\"Check token_type\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.token_type).to.eql('bearer');",
							"});",
							"pm.environment.set(\"token\",  pm.response.json().access_token);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "grant_type",
							"value": "authorization_code",
							"type": "text"
						},
						{
							"key": "redirect_uri",
							"value": "https://www.google.com",
							"type": "text"
						},
						{
							"key": "code",
							"value": "{{auth_code}}",
							"type": "text"
						},
						{
							"key": "code_verifier",
							"value": "09jR4DQJIqyFUy2i-PllgD~Li6RbGqvORtTsrnktqjtYis5fMa_tO_--QT9r7d6vazhBfofnSj9JLzyI2u3PYflfi_VL.84dEhZ6yQ.fxCB9T9r7aB7lVUrIVwsUy7Ds",
							"type": "text"
						},
						{
							"key": "client_assertion",
							"value": "{{private_key_jwt}}",
							"type": "text"
						},
						{
							"key": "client_assertion_type",
							"value": "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/token",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "After receiving the authorization code, we exchange it with the `access_token` at the /token endpoint. \n\nThis client is configured to use `private_key_jwt`. The `private_key_jwt` has expiry.\n\nIf it's already expired, you can copy the current `private_key_jwt` from your environment; paste into `jwt.io` website. Then modify the `exp` claim.\n\nIn order to sign it again properly, need to copy the private key and public key supplied in the enablement materials under `keys/private_key_jwt`. Then copy paste it back to your postman environment."
			},
			"response": []
		},
		{
			"name": "par: Pushed authorization request",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(201);",
							"});",
							"pm.environment.set(\"request_uri\", pm.response.json().request_uri);",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "client_id",
							"value": "{{client_basic_id}}",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "openid profile",
							"type": "text"
						},
						{
							"key": "redirect_uri",
							"value": "https://www.google.com",
							"type": "text"
						},
						{
							"key": "response_type",
							"value": "token id_token",
							"type": "text"
						},
						{
							"key": "state",
							"value": "hwevopawaf82r72uhaowefa",
							"type": "text"
						},
						{
							"key": "client_assertion",
							"value": "{{private_key_jwt}}",
							"type": "text"
						},
						{
							"key": "client_assertion_type",
							"value": "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
							"type": "text"
						},
						{
							"key": "nonce",
							"value": "ncayw7a42aofawlfawfa",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/par",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"par"
					]
				},
				"description": "Pushed authorization request (PAR) enables an OAuth client to push the payload of an authorization request directly to the authorization server. A request URI value is received in exchange; it is used as reference to the authorization request payload data in a subsequent call to the authorization endpoint via the user agent."
			},
			"response": []
		},
		{
			"name": "par: Authorize with request_uri",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const $ = cheerio.load(pm.response.text());",
							"const $form = $('form');",
							"const action = $form.attr('action');",
							"pm.environment.set(\"consentPath\", action)"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disableBodyPruning": true,
				"followRedirects": false
			},
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "iv-jwt",
						"value": "{{iv-jwt}}",
						"type": "text",
						"description": "needed to simulate user session"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": []
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/authorize?client_id={{client_basic_id}}&request_uri={{request_uri}}",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"authorize"
					],
					"query": [
						{
							"key": "client_id",
							"value": "{{client_basic_id}}"
						},
						{
							"key": "request_uri",
							"value": "{{request_uri}}"
						}
					]
				},
				"description": "After making request using PAR successfully in the previous steps, it will return `request_uri`.\n\nIn this step, you continue the flow by hitting `/authorize` endpoint with `client_id` and the `request_uri`.\n\nTypically, you should copy the URL here and do it from the browser.\n\nThe step here is provided to simulate the implicit flow + PAR using postman.\n\nIn this postman collection, the user credential is injected using `iv-jwt` header. This is telling the system that the user has logged in.\n\nIn the actual deployment, ISVA OP will be fronted by a reverse proxy. This user session will be manage by the reverse proxy and forwarded to ISVA OP.\n\nWhen `iv-jwt` header is not available, the system will redirect you to `/oauth2/auth` endpoint to trigger user login.\n\nWhen `definition` configure the `consent_prompt` as `ALWAYS_PROMPT`, this step will result in consent page being returned. Otherwise, this step may return the `access_token` and `id_token` directly."
			},
			"response": []
		},
		{
			"name": "par: Submit Consent",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const querystring = require('querystring');",
							"let params = pm.response.headers.get('location').split('#')",
							"pm.environment.set(\"token\", querystring.parse(params[1]).access_token)"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "iv-jwt",
						"value": "{{iv-jwt}}",
						"type": "text",
						"description": "needed to simulate user session"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "trust_level",
							"value": "permit",
							"description": "permit or deny",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "openid",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "profile",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}{{consentPath}}",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}{{consentPath}}"
				},
				"description": "If the previous step returned a consent page, this step is used to submit the consents.\n\nWhen the consent decision is to `permit`, then `access_token` and `id_token` is returned as requested."
			},
			"response": []
		},
		{
			"name": "ciba1: Initialize Backchannel Authentication",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GrabAuthReqID\", function () {",
							"    pm.response.to.have.status(200);",
							"    var jsonData = pm.response.json();",
							"    if (jsonData.auth_req_id) {",
							"        pm.environment.set(\"auth_req_id\", jsonData.auth_req_id);",
							"    }",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "X-Client-Certificate",
						"value": "{{x-client-certificate}}",
						"description": "only needed if you test directly to ISVAOP container",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "client_id",
							"value": "{{client_ciba_id}}",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "openid profile",
							"type": "text"
						},
						{
							"key": "login_hint",
							"value": "notifyme@test.com",
							"type": "text"
						},
						{
							"key": "user_code",
							"value": "validCode",
							"type": "text"
						},
						{
							"key": "binding_message",
							"value": "validBindingMessage",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/ciba",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"ciba"
					]
				},
				"description": "#### Overview\n\nCIBA is another way to get user authorization using out-of-band authentication. After CIBA request is received, the authorization server (OP) will find a way to notify and authenticate the user.\n\nWhile CIBA client will continue to poll the token endpoint (when operating in poll mode) or waiting for notification (when operating in ping mode) before hitting the token endpoint.\n\nIn this postman series, the CIBA request will notify the user via SMS or Email - in the notification message, it will ask the user to click the link to authenticate and continue the flow.\n\nThis may not the best way to do backchannel authentication - as the link might be tampered. But this is just to demonstrate one way how this could be done.\n\nIn order to continue to next step, you need to copy the link printed in the ISVA OP console.\n\nIn this example, the client authentication is done using MTLS authentication.\n\nISVA OP deployment typically is fronted by a reverse proxy. So the MTLS connection is terminated there. Then the reverse proxy will forward the client certificate in an HTTP header (configurable in `provider.yml`) to ISVA OP.\n\nISVA OP will extract information from the client certificate, such as subject DN, and will match it with information in the client configuration.\n\nNote: if you are testing with fronted reverse proxy, then you only need to configure postman to send client certificate. However, if you directly hitting ISVA OP container, you can simulate it by sending `X-Client-Certificate` header."
			},
			"response": []
		},
		{
			"name": "ciba1: User Authorization Endpoint",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const $ = cheerio.load(pm.response.text());",
							"const $form = $('form');",
							"const action = $form.attr('action');",
							"pm.environment.set(\"consentPath\", action)"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disableBodyPruning": true,
				"followRedirects": false
			},
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "iv-jwt",
						"value": "{{iv-jwt}}",
						"description": "needed to simulate user session",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": []
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/ciba_user_authorize/10abd4f2-9c4c-42df-9ff4-90a265b4a78a",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"ciba_user_authorize",
						"10abd4f2-9c4c-42df-9ff4-90a265b4a78a"
					]
				},
				"description": "#### Overview\n\nNote down the link printed in the ISVA OP console.\nExample:\n\n```\nUser Authorize endpoint: https://isvaop.ibm.com:445/oauth2/ciba_user_authorize/1107a319-2627-42d5-9b0c-3dc492acc5d9\"\n\n```\n\nIn this postman collection, the user credential is injected using `iv-jwt` header. This is telling the system that the user has logged in.\n\nIn the actual deployment, ISVA OP will be fronted by a reverse proxy. This user session will be manage by the reverse proxy and forwarded to ISVA OP.\n\nWhen `iv-jwt` header is not available, the system will redirect you to `/oauth2/auth` endpoint to trigger user login.\n\nWhen `definition` configure the `consent_prompt` as `ALWAYS_PROMPT`, this step will result in consent page being returned. Otherwise, this step may show the successful page directly."
			},
			"response": []
		},
		{
			"name": "ciba1: Submit Consent",
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "iv-jwt",
						"value": "{{iv-jwt}}",
						"type": "text",
						"description": "needed to simulate user session"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "trust_level",
							"value": "permit",
							"description": "permit or deny",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "openid",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "profile",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}{{consentPath}}",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}{{consentPath}}"
				},
				"description": "If the previous step returned a consent page, this step is used to submit the consents.\n\nWhen the consent decision is to `permit`, then successful page will be shown."
			},
			"response": []
		},
		{
			"name": "ciba1: Polling at Token Endpoint",
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "X-Client-Certificate",
						"value": "{{x-client-certificate}}",
						"description": "only needed if you test directly to ISVAOP container",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "client_id",
							"value": "{{client_ciba_id}}",
							"type": "text"
						},
						{
							"key": "auth_req_id",
							"value": "{{auth_req_id}}",
							"type": "text"
						},
						{
							"key": "grant_type",
							"value": "urn:openid:params:grant-type:ciba",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/token",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "After submitting the initial CIBA request, since this CIBA client running in poll mode,\nthe RP will continue polling `/token` endpoint.\n\nOnce the user authentication is done, the `access_token` and optionally `refresh_token` will be returned.\n\nIn this example, the client authentication is done using MTLS authentication.\n\nISVA OP deployment typically is fronted by a reverse proxy. So the MTLS connection is terminated there. Then the reverse proxy will forward the client certificate in an HTTP header (configurable in `provider.yml`) to ISVA OP.\n\nISVA OP will extract information from the client certificate, such as subject DN, and will match it with information in the client configuration.\n\nNote: if you are testing with fronted reverse proxy, then you only need to configure postman to send client certificate. However, if you directly hitting ISVA OP container, you can simulate it by sending `X-Client-Certificate` header."
			},
			"response": []
		},
		{
			"name": "ciba2: Initialize Backchannel Authentication",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GrabAuthReqID\", function () {",
							"    pm.response.to.have.status(200);",
							"    var jsonData = pm.response.json();",
							"    if (jsonData.auth_req_id) {",
							"        pm.environment.set(\"auth_req_id\", jsonData.auth_req_id);",
							"    }",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "X-Client-Certificate",
						"value": "{{x-client-certificate}}",
						"description": "only needed if you test directly to ISVAOP container",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "client_id",
							"value": "{{client_ciba_id}}",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "openid profile",
							"type": "text"
						},
						{
							"key": "login_hint",
							"value": "updatestatus@test.com",
							"type": "text"
						},
						{
							"key": "user_code",
							"value": "validCode",
							"type": "text"
						},
						{
							"key": "binding_message",
							"value": "validBindingMessage",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/ciba",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"ciba"
					]
				},
				"description": "#### Overview\n\nCIBA is another way to get user authorization using out-of-band authentication. After CIBA request is received, the authorization server (OP) will find a way to notify and authenticate the user.\n\nWhile CIBA client will continue to poll the token endpoint (when operating in poll mode) or waiting for notification (when operating in ping mode) before hitting the token endpoint.\n\nIn this postman series, the CIBA request will trigger user authentication. And when the authentication is done, the authenticator will call status endpoint to update the authentication status.\n\nIn order to continue to next step, you need to copy the link printed in the ISVA OP console.\n\nIn this example, the client authentication is done using MTLS authentication.\n\nISVA OP deployment typically is fronted by a reverse proxy. So the MTLS connection is terminated there. Then the reverse proxy will forward the client certificate in an HTTP header (configurable in `provider.yml`) to ISVA OP.\n\nISVA OP will extract information from the client certificate, such as subject DN, and will match it with information in the client configuration.\n\nNote: if you are testing with fronted reverse proxy, then you only need to configure postman to send client certificate. However, if you directly hitting ISVA OP container, you can simulate it by sending `X-Client-Certificate` header."
			},
			"response": []
		},
		{
			"name": "ciba2: Authenticator call Status Update",
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "xFUKQYHB_haB4B6QEMtUGyoAP-GZebL5S4Z4WGug4qE.NJcFu6dAdrHBbRRnwhgIPOxd4aESdRchebW0LB12kPJVyjyg59mGgRsUt-ZAh5OIUAOMqeBnO6ksPxuRdI6AMA",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\n    \"status\": \"success\",\n    \"metadata\": {\n        \"name\": \"John Doe\",\n        \"uid\": \"jdoe\",\n        \"preferred_username\": \"John Doe\",\n        \"given_name\": \"John\",\n        \"family_name\": \"Doe\",\n        \"AUTHENTICATION_LEVEL\": \"2\"\n    }\n}"
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/ciba_status_update/1cc9d644-f831-4a7d-9008-4ea68acf3ea2",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"ciba_status_update",
						"1cc9d644-f831-4a7d-9008-4ea68acf3ea2"
					]
				},
				"description": "Note down the link printed in the ISVA OP console. Example:\n\n```\nStatus Update endpoint: https://isvaop.ibm.com:445/oauth2/ciba_status_update/b4b60f6d-0a13-4f34-a97e-15cd93029f72\"\n\nBearer token: 5R5kT8olz2dnyUl0VTSd3YwCuIUVHh-cG36ft6sPjzo.kBoUkNBTbJDRWcrqddIWMRiTTaiHLzp0qgvCUwqWMBGJTWJ9JWKde9gIOZUu8HesbEINK2BWl0711EZd7WXRXQ\"\n\n```\nReplace the UUID in this URL with the UUID of the /ciba_status_update.\nAdd the bearer token in the authorization tab."
			},
			"response": []
		},
		{
			"name": "ciba2: Polling at Token Endpoint",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"pm.environment.set(\"token\",  pm.response.json().access_token);"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "X-Client-Certificate",
						"value": "{{x-client-certificate}}",
						"description": "only needed if you test directly to ISVAOP container",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "client_id",
							"value": "{{client_ciba_id}}",
							"type": "text"
						},
						{
							"key": "auth_req_id",
							"value": "{{auth_req_id}}",
							"type": "text"
						},
						{
							"key": "grant_type",
							"value": "urn:openid:params:grant-type:ciba",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/token",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "After submitting the initial CIBA request, since this CIBA client running in poll mode,\nthe RP will continue polling `/token` endpoint.\n\nOnce the user authentication is done, the `access_token` and optionally `refresh_token` will be returned.\n\nIn this example, the client authentication is done using MTLS authentication.\n\nISVA OP deployment typically is fronted by a reverse proxy. So the MTLS connection is terminated there. Then the reverse proxy will forward the client certificate in an HTTP header (configurable in `provider.yml`) to ISVA OP.\n\nISVA OP will extract information from the client certificate, such as subject DN, and will match it with information in the client configuration.\n\nNote: if you are testing with fronted reverse proxy, then you only need to configure postman to send client certificate. However, if you directly hitting ISVA OP container, you can simulate it by sending `X-Client-Certificate` header."
			},
			"response": []
		},
		{
			"name": "ciba3: Initialize Backchannel Authentication",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GrabAuthReqID\", function () {",
							"    pm.response.to.have.status(200);",
							"    var jsonData = pm.response.json();",
							"    if (jsonData.auth_req_id) {",
							"        pm.environment.set(\"auth_req_id\", jsonData.auth_req_id);",
							"    }",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "X-Client-Certificate",
						"value": "{{x-client-certificate}}",
						"description": "only needed if you test directly to ISVAOP container",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "client_id",
							"value": "{{client_ciba_id}}",
							"type": "text"
						},
						{
							"key": "scope",
							"value": "openid profile",
							"type": "text"
						},
						{
							"key": "login_hint",
							"value": "checkstatuspass@test.com",
							"description": "checkstatuspass@test.com or checkstatusfail@test.com",
							"type": "text"
						},
						{
							"key": "user_code",
							"value": "validCode",
							"type": "text"
						},
						{
							"key": "binding_message",
							"value": "validBindingMessage",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/ciba",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"ciba"
					]
				},
				"description": "#### Overview\n\nCIBA is another way to get user authorization using out-of-band authentication. After CIBA request is received, the authorization server (OP) will find a way to notify and authenticate the user.\n\nWhile CIBA client will continue to poll the token endpoint (when operating in poll mode) or waiting for notification (when operating in ping mode) before hitting the token endpoint.\n\nIn this postman series, the CIBA request will trigger user authentication. The authenticator provides an endpoint to check the status.\nSo as the CIBA client doing a poll, it will hit the check status endpoint of the authenticator. This option is not permitted when CIBA client operating in ping mode.\n\nIn this example, the client authentication is done using MTLS authentication.\n\nISVA OP deployment typically is fronted by a reverse proxy. So the MTLS connection is terminated there. Then the reverse proxy will forward the client certificate in an HTTP header (configurable in `provider.yml`) to ISVA OP.\n\nISVA OP will extract information from the client certificate, such as subject DN, and will match it with information in the client configuration.\n\nNote: if you are testing with fronted reverse proxy, then you only need to configure postman to send client certificate. However, if you directly hitting ISVA OP container, you can simulate it by sending `X-Client-Certificate` header."
			},
			"response": []
		},
		{
			"name": "ciba3: Polling at Token Endpoint",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"pm.environment.set(\"token\",  pm.response.json().access_token);",
							"pm.environment.set(\"refresh_token\", pm.response.json().refresh_token);"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "X-Client-Certificate",
						"value": "{{x-client-certificate}}",
						"description": "only needed if you test directly to ISVAOP container",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "client_id",
							"value": "{{client_ciba_id}}",
							"type": "text"
						},
						{
							"key": "auth_req_id",
							"value": "{{auth_req_id}}",
							"type": "text"
						},
						{
							"key": "grant_type",
							"value": "urn:openid:params:grant-type:ciba",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/token",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "After submitting the initial CIBA request, since this CIBA client running in poll mode,\nthe RP will continue polling `/token` endpoint.\n\nOnce the user authentication is done, the `access_token` and optionally `refresh_token` will be returned.\n\nIn this example, the client authentication is done using MTLS authentication.\n\nISVA OP deployment typically is fronted by a reverse proxy. So the MTLS connection is terminated there. Then the reverse proxy will forward the client certificate in an HTTP header (configurable in `provider.yml`) to ISVA OP.\n\nISVA OP will extract information from the client certificate, such as subject DN, and will match it with information in the client configuration.\n\nNote: if you are testing with fronted reverse proxy, then you only need to configure postman to send client certificate. However, if you directly hitting ISVA OP container, you can simulate it by sending `X-Client-Certificate` header."
			},
			"response": []
		},
		{
			"name": "ciba3: Refresh Token",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"pm.environment.set(\"token\",  pm.response.json().access_token);"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"followRedirects": false
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "X-Client-Certificate",
						"value": "{{x-client-certificate}}",
						"description": "only needed if you test directly to ISVAOP container",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "client_id",
							"value": "{{client_ciba_id}}",
							"type": "text"
						},
						{
							"key": "refresh_token",
							"value": "{{refresh_token}}",
							"type": "text"
						},
						{
							"key": "grant_type",
							"value": "refresh_token",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/token",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "This is an example of refresh token flow.\nWhen the `access_token` generated has expired, and `refresh_token` is available, you can exchange the `refresh_token` for new `access_token` (and `refresh_token`).\n\nIn this example, the client authentication is done using MTLS authentication.\n\nISVA OP deployment typically is fronted by a reverse proxy. So the MTLS connection is terminated there. Then the reverse proxy will forward the client certificate in an HTTP header (configurable in `provider.yml`) to ISVA OP.\n\nISVA OP will extract information from the client certificate, such as subject DN, and will match it with information in the client configuration.\n\nNote: if you are testing with fronted reverse proxy, then you only need to configure postman to send client certificate. However, if you directly hitting ISVA OP container, you can simulate it by sending `X-Client-Certificate` header."
			},
			"response": []
		},
		{
			"name": "dpop: *BETA* ROPC flow",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"pm.test(\"Check Scope\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.scope).to.eql('openid');",
							"});",
							"pm.test(\"Check token_type\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.token_type).to.eql('DPoP');",
							"});",
							"pm.environment.set(\"token\",  pm.response.json().access_token);",
							"pm.environment.set(\"refresh_token\", pm.response.json().refresh_token);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "dpop",
						"value": "{{dpop_header}}",
						"type": "text"
					},
					{
						"key": "x-forwarded-host",
						"value": "isvaop.ibm.com:445",
						"description": "only needed if you test directly to ISVAOP container",
						"type": "text"
					},
					{
						"key": "X-Client-Certificate",
						"value": "{{x-client-certificate}}",
						"description": "only needed if you test directly to ISVAOP container",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "scope",
							"value": "openid profile",
							"type": "text"
						},
						{
							"key": "grant_type",
							"value": "password",
							"type": "text"
						},
						{
							"key": "username",
							"value": "{{username}}",
							"type": "text"
						},
						{
							"key": "password",
							"value": "{{password}}",
							"type": "text"
						},
						{
							"key": "client_id",
							"value": "{{client_dpop_id}}",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/token",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "#### Overview\n\nDPoP (Demonstrating Proof-of-Possession) is an application-level mechanism for sender-constraining OAuth access and refresh tokens.  It enables a client to prove the possession of a public/private key pair by including a DPoP header in an HTTP request.\n\nClient configuration related to DPoP are:\n```\ndpop_bound_access_tokens: true\ndpop_signing_alg: PS256\ndpop_single_use_jti: false\n```\n\nBy setting `dpop_bound_access_tokens` to true, if `dpop` HTTP header is not received, the authorization server will throw error. You can also choose the allowed DPoP signing algorithm, and whether a DPoP JWT can be reused by checking the `jti` uniqueness.\n\nExample of DPoP JWT header:\n```\n{\n  \"alg\": \"PS256\",\n  \"typ\": \"dpop+jwt\",\n  \"jwk\": {\n    \"kty\": \"RSA\",\n    \"e\": \"AQAB\",\n    \"n\": \"g1gHR_yRrj179tVA-...I9Q\"\n  }\n}\n```\n\nExample of DPoP JWT payload:\n```\n{\n  \"iat\": 1663036032,\n  \"exp\": 1663037800,\n  \"htm\": \"POST\",\n  \"htu\": \"https://isvaop.ibm.com:445/oauth2/token\",\n  \"jti\": \"71822b37-27f4-46bc-8782-ffeab7ecee233\"\n}\n```\n\nNote: if you find that the DPoP JWT provided in this sample has expired, you can copy the JWT from Postman environment, open up in jwt.io and modify the `exp` claim. To sign the JWT again, you can use the private-public key under `keys/dpop`."
			},
			"response": []
		},
		{
			"name": "dpop: *BETA* Introspection",
			"protocolProfileBehavior": {
				"disableCookies": true,
				"tlsPreferServerCiphers": true
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "X-Client-Certificate",
						"value": "{{x-client-certificate}}",
						"description": "only needed if you test directly to ISVAOP container",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "client_id",
							"value": "{{client_dpop_id}}",
							"type": "text"
						},
						{
							"key": "token",
							"value": "{{token}}",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/introspect",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"introspect"
					]
				},
				"description": "#### Overview\n\nQuery the authorization server to determine the set of metadata for a given token.\nThis metadata includes whether or not the token is currently active (or if it has expired or otherwise been revoked), what rights of access the token carries (usually conveyed through OAuth 2.0 scopes), and the authorization context in which the token was granted (including who authorized the token and which client it was issued to).\n\nFor DPoP access token, the `token_type` is `DPoP`"
			},
			"response": []
		},
		{
			"name": "dpop: *BETA* Refresh Token",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"pm.test(\"Check Scope\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.scope).to.eql('openid');",
							"});",
							"pm.test(\"Check token_type\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.token_type).to.eql('bearer');",
							"});",
							"pm.environment.set(\"token\",  pm.response.json().access_token);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "noauth"
				},
				"method": "POST",
				"header": [
					{
						"key": "dpop",
						"value": "{{dpop_header}}",
						"type": "text"
					},
					{
						"key": "x-forwarded-host",
						"value": "isvaop.ibm.com:445",
						"description": "only needed if you test directly to ISVAOP container",
						"type": "text"
					},
					{
						"key": "X-Client-Certificate",
						"value": "{{x-client-certificate}}",
						"description": "only needed if you test directly to ISVAOP container",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "grant_type",
							"value": "refresh_token",
							"type": "text"
						},
						{
							"key": "refresh_token",
							"value": "{{refresh_token}}",
							"type": "text"
						},
						{
							"key": "client_id",
							"value": "{{client_dpop_id}}",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "https://{{OPHost}}:{{OPPort}}/oauth2/token",
					"protocol": "https",
					"host": [
						"{{OPHost}}"
					],
					"port": "{{OPPort}}",
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "In this example, we are doing refresh token flow using DPoP bound refresh token generated in previous step.\n\nIf you are using DPoP header signed using different certificate, then the refresh token flow will fail."
			},
			"response": []
		}
	]
}